    <#@ template language="C#" hostspecific="True" debug="True" #>
    <#@ output extension="cs" #>
    <#@ assembly name="System.Core" #>
    <#@ assembly name="System.Configuration" #>
    <#@ assembly name="System.Xml" #>
    <#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
    <#@ assembly name="EnvDTE" #>
    <#@ assembly name="EnvDTE80" #>
    <#@ import namespace="System.Collections.Generic" #>
    <#@ import namespace="System.IO" #>
    <#@ import namespace="System.Linq" #>
    <#@ import namespace="System.Text" #>
    <#@ import namespace="System.Configuration" #>
    <#@ import namespace="System.Text.RegularExpressions" #>
    <#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
    <#@ import namespace="EnvDTE" #>
    <#@ import namespace="EnvDTE80" #>
   
        <#
		// http://imaginarydevelopment.blogspot.co.uk/2010/11/static-reflection-or-t4-with-envdte.html (amend if project folders) 
		var serviceProvider = Host as IServiceProvider;
        if (serviceProvider != null) {
            Dte = serviceProvider.GetService(typeof(SDTE)) as DTE;
        }

        // Fail if we couldn't get the DTE. This can happen when trying to run in TextTransform.exe
        if (Dte == null) {
            throw new Exception("T4Generator can only execute through the Visual Studio host");
        }

		Project currentProject = GetProjectContainingT4File(Dte);
        var mainNamespace = currentProject.Properties.Item("RootNamespace").Value.ToString();
		WriteLine("// !!! This file has been autogenerated and any manual changes wil be overwritten !!!");
		WriteLine(string.Format("namespace {0} {{",mainNamespace));
		PushIndent("\t");
		WriteLine("class ServiceLayer : BaseServiceLayerClient,IServiceLayer {");
   
        foreach(var project in Dte.Solution.Projects.Cast<Project>()
            .Where(p=> p.CodeModel!=null && p.Name!="Solution Items"))
        {
				ProcessFileCodeModel(project);
        }
		WriteLine("}");
		PopIndent();
		WriteLine("}");
       
    #>


<#+
    bool AlwaysKeepTemplateDirty = true;
    static DTE Dte;

       
	void ProcessFileCodeModel(Project project)
    {
        foreach(var item in project.ProjectItems.Cast<ProjectItem>())
        {
            if(item.FileCodeModel!=null )
            {
                RecurseFindElements(item.FileCodeModel.CodeElements);
            }
        }
    }
	private void RecurseFindElements(CodeElements codeElements) 
    {
     
      var q=codeElements.Cast<CodeElement>( )
		//.Where((x => x is CodeNamespace || (x is CodeInterface && ((CodeInterface)x).Attributes.Count>0)));
	  .Where((x => x is CodeNamespace || (x is CodeInterface && ((CodeInterface)x).Attributes.Item.Any(typeof(ServiceLayerDefinitionAttribute)))));

        
      foreach (var element in q)
      {
		// here to write interface method implementations
        if (element is CodeInterface)
        {
		   var c = (CodeInterface)element;
		   foreach (CodeFunction method in c.Members.Cast<CodeElement>( ))
		   {
				PushIndent("\t");
				var mytype = (((CodeFunction)method).Type.AsString);
				Write (string.Format("public {0} {1}(", mytype, method.Name));

               var parameters = ((CodeFunction)method).Parameters;
			   int count = 0;
               foreach (CodeParameter p in parameters) 
               {
					if (count++ != 0) Write(", ");
					Write(string.Format("{0} {1}",p.Type.AsString,p.Name));
               }
			   string methodToCall = (mytype.Equals("void")) ? "BaseCallMeOneWay" : "return BaseCallMe";
			   Write(string.Format(") {{ {0}(\"{1}\"", methodToCall, method.Name)); 
               foreach (CodeParameter p in parameters) 
               {
					Write (string.Format(", {0}",p.Name));
               }
			   PopIndent();
			   WriteLine("); }");
		    }
        }
        if (element is CodeNamespace)
        {
            var ns=(CodeNamespace)element;
            RecurseFindElements(ns.Members);
        }
      }
    }


Project GetProjectContainingT4File(DTE dte) {

    // Find the .tt file's ProjectItem
    ProjectItem projectItem = dte.Solution.FindProjectItem(Host.TemplateFile);

    // If the .tt file is not opened, open it
    if (projectItem.Document == null)
        projectItem.Open(Constants.vsViewKindCode);

    if (AlwaysKeepTemplateDirty) {
        // Mark the .tt file as unsaved. This way it will be saved and update itself next time the
        // project is built. Basically, it keeps marking itself as unsaved to make the next build work.
        // Note: this is certainly hacky, but is the best I could come up with so far.
        projectItem.Document.Saved = false;
    }

    return projectItem.ContainingProject;
}
#>
